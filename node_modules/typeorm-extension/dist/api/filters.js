"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyRequestFilters = exports.applyRequestFilter = exports.applyFilters = exports.applyFiltersTransformed = exports.transformFilters = void 0;
var typeorm_1 = require("typeorm");
var change_case_1 = require("change-case");
var utils_1 = require("./utils");
var utils_2 = require("./utils");
var field_1 = require("./utils/field");
// --------------------------------------------------
function buildOptions(options) {
    var _a, _b;
    options !== null && options !== void 0 ? options : (options = {});
    if (options.aliasMapping) {
        options.aliasMapping = utils_1.buildAliasMapping(options.aliasMapping, {
            keyCase: options.stringCase,
            keyDepthCharacter: '.'
        });
    }
    else {
        options.aliasMapping = {};
    }
    (_a = options.includes) !== null && _a !== void 0 ? _a : (options.includes = []);
    (_b = options.stringCase) !== null && _b !== void 0 ? _b : (options.stringCase = utils_2.getDefaultStringCase());
    return options;
}
function transformFilters(data, options) {
    var _a;
    options = options !== null && options !== void 0 ? options : {};
    // If it is an empty array nothing is allowed
    if (typeof options.allowed !== 'undefined' &&
        Object.keys(options.allowed).length === 0) {
        return [];
    }
    var prototype = Object.prototype.toString.call(data);
    /* istanbul ignore next */
    if (prototype !== '[object Object]') {
        return [];
    }
    var length = Object.keys(data).length;
    if (length === 0) {
        return [];
    }
    options = buildOptions(options);
    var temp = {};
    // transform to appreciate data format & validate input
    for (var key in data) {
        /* istanbul ignore next */
        if (!data.hasOwnProperty(key)) {
            continue;
        }
        var value = data[key];
        if (typeof value !== 'string' &&
            typeof value !== 'number' &&
            typeof value !== 'boolean') {
            continue;
        }
        if (typeof value === 'string') {
            value = value.trim();
            var stripped = value.replace('/,/g', '');
            if (stripped.length === 0) {
                continue;
            }
        }
        key = utils_2.changeStringCase(key, options.stringCase);
        if (options.aliasMapping.hasOwnProperty(key)) {
            key = options.aliasMapping[key];
        }
        var fieldDetails = field_1.getFieldDetails(key);
        if (!utils_1.isFieldAllowedByIncludes(fieldDetails, options.includes, { queryAlias: options.queryAlias })) {
            continue;
        }
        var keyWithQueryAlias = utils_1.buildFieldWithQueryAlias(fieldDetails, options.queryAlias);
        if (typeof options.allowed !== 'undefined' &&
            options.allowed.indexOf(key) === -1 &&
            options.allowed.indexOf(keyWithQueryAlias) === -1) {
            continue;
        }
        temp[keyWithQueryAlias] = value;
    }
    var items = [];
    /* istanbul ignore next */
    var run = 0;
    for (var key in temp) {
        /* istanbul ignore next */
        if (!temp.hasOwnProperty(key)) {
            continue;
        }
        run++;
        var value = temp[key];
        /* istanbul ignore next */
        var paramKey = 'filter_' + change_case_1.snakeCase(key) + '_' + run;
        var whereKind = run === 1 ? 'where' : 'andWhere';
        var queryString = [
            key
        ];
        var isInOperator = false;
        if (typeof value === 'string') {
            var isNegationPrefix = value.charAt(0) === '!';
            if (isNegationPrefix)
                value = value.slice(1);
            var isLikeOperator = value.charAt(0) === '~';
            if (isLikeOperator)
                value = value.slice(1);
            isInOperator = value.includes(',');
            if (isInOperator || isLikeOperator) {
                if (isNegationPrefix) {
                    queryString.push('NOT');
                }
                if (isLikeOperator) {
                    queryString.push('LIKE');
                }
                else {
                    queryString.push('IN');
                }
            }
            else {
                if (isNegationPrefix) {
                    queryString.push("!=");
                }
                else {
                    queryString.push("=");
                }
            }
            if (isLikeOperator) {
                value += '%';
            }
            if (isInOperator) {
                queryString.push('(:...' + paramKey + ')');
            }
            else {
                queryString.push(':' + paramKey);
            }
        }
        else {
            isInOperator = false;
            queryString.push("=");
            queryString.push(':' + paramKey);
        }
        items.push({
            type: whereKind,
            query: queryString.join(" "),
            bindings: (_a = {}, _a[paramKey] = isInOperator ? value.split(',') : value, _a)
        });
    }
    return items;
}
exports.transformFilters = transformFilters;
function applyFiltersTransformed(query, data) {
    /* istanbul ignore next */
    if (data.length > 0) {
        query.andWhere(new typeorm_1.Brackets(function (qb) {
            for (var i = 0; i < data.length; i++) {
                qb[data[i].type](data[i].query, data[i].bindings);
            }
        }));
    }
    return data;
}
exports.applyFiltersTransformed = applyFiltersTransformed;
/**
 * Apply raw filter data on query.
 *
 * @param query
 * @param data
 * @param options
 */
function applyFilters(query, data, options) {
    return applyFiltersTransformed(query, transformFilters(data, options));
}
exports.applyFilters = applyFilters;
// --------------------------------------------------
/**
 * @deprecated
 */
function applyRequestFilter(query, data, aliasMapping, options) {
    return applyRequestFilters(query, data, aliasMapping, options);
}
exports.applyRequestFilter = applyRequestFilter;
/**
 * @deprecated
 * @param query
 * @param data
 * @param aliasMapping
 * @param options
 */
function applyRequestFilters(query, data, aliasMapping, options) {
    return applyFiltersTransformed(query, transformFilters(data, __assign(__assign({}, options), { aliasMapping: aliasMapping })));
}
exports.applyRequestFilters = applyRequestFilters;
//# sourceMappingURL=filters.js.map